---
name: 3.7.1.1
title: 3.7.1.1 - iBGP Peerings
short-title: iBGP Peerings
category: 3.7.1 Establishing Peerings
collection: bgp
layout: page
exam: both
sidebar: bgp_sidebar
permalink: 3.7.1.1.html
folder: bgp
---
#### Background
If a BGP session is established between two neighbors in the same autonomous system, the session is internal BGP. iBGP is needed whenever BGP-advertised information must be passed within a given AS. Traditionally, iBGP is associated with transit autonomous systems. A stub AS usually runs EBGP at one or more edge routers only, and routes packets to and from the edge routers via an IGP.

We saw before that since an AS is not added to the path as routes are passed between iBGP peers, that there becomes the possibility for routing loops. TCP helps solve this as communication between peers is point-to-point. But that introduces the need for two levels of information to be considered when setup up iBGP:
1. Next-hop information about the advertised prefix
2. Next-hop information about the prefix next-hop address.

But since you should not redistribute eBGP routes into the IGP, the internal routers may not have the reachability information of how to access the next-hop address. Good practice dictates that BGP learned routes should stay within BGP. If the external routes need to be distributed to internal routers, distribute them using iBGP. This means a full mesh should be created between all BGP routers within an AS. Another golden rule of iBGP is that “routes learned from an internal neighbor are never sent to another internal neighbor.” So even with this loop-free rule in place, a full mesh ensures that all peers internal to the AS have the same information.

You have to remember that there is no requirement for iBGP routers to be physically connected. So iBGP peers may have several routers between them. That is another reason why next-hop reachability is more complex with iBGP. Since they do not have to be physically connected, the TTL for an iBGP session is set to 255 instead of the 1 we will see with eBGP.

BGP is a normal TCP application, which means that a TCP client initiates the session to the TCP server with a SYN packet going to the well-known port of 179. If the BGP server is configured to accept the session, a reply with SYN/ACK comes from port 179 back to the client, going to the high port number generated by the client. If both BGP peers attempt to establish the connection at the same time, RFC 4271 (A Border Gateway Protocol 4) defines a “BGP Connection Collision Detection” mechanism, in which essentially the session originated from the device with the higher BGP router-id is maintained, and the secondary session is dropped. 


#### Operation
iBGP peering is configured similarly to eBGP peering but rather than using a different as for the **neighbor remote-as** command, you use the same AS as was indicated with the **router bgp** command.
```
`R1(config)# router bgp 100
R1(config-router)# neighbor 192.168.17.10 remote-as 100
```
`
IBGP sessions often span multiple router hops; a router cannot establish an IBGP session unless it knows how to reach its peer. Therefore, one of the first steps in troubleshooting an IBGP session that stays in Active state (listening for a configured neighbor) is to look in the routing tables of both neighbors and see if they know how to find each other



